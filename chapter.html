
<!DOCTYPE html>
<div class='chapter' id='ch.ruby-intro'>  
  <h2 class='title'>An Introduction to Ruby</h2>
  
    <p>
    Every excellent Rails programmer has a thorough understanding of Ruby — after all, Rails is written in Ruby.  Trying
    to write a Rails program without knowing Ruby is like trying to write a limerick in English without knowing English
    – you could do it with the help of a translator, but it would be much easier with fluency in the language.</p>
    <p>Before we dig into Rails, let's get some grounding in Ruby. Our
    goal right now is to learn Ruby basics. We won't worry about formalized testing yet, instead we'll start with
    interactive testing, poking around the language through its interactive console.  In the next chapter we will start
    doing test-driven development (TDD) using what we learn about Ruby in this chapter.  By the end of this chapter we
    will have created some Ruby code, but we will still have plenty to learn about it.  We will explain key Ruby
    concepts as we come to them in the following chapters</p>
    <p>In this book, you will learn just enough Ruby to build Rails
    applications, but we highly recommend diving deeper into the language with Chris Pine's Learn to Program in Ruby or
    Programming Ruby by our very own publishers Dave and Andy,
    along with Chad Fowler<span class='footnote'><p>Chad Fowler started the very first U.S. RubyConf in 2001, which he still
    co-organizes along with RailsConf.</p></span>.
    Chris Pine's book is written for non-programmers, but many experienced programmers find it a fun way to learn the
    language. Programming Ruby, also known as “the Pickaxe book” for the its cover art, is the definitive reference to the language. It was the first English-language
    book about Ruby, and has been enthusiastically kept up to date.
    </p>
    <div class='ask_sidebar'>
    <h2 class='title'>What's an Object?</h2>
<p>
Objects allow us to associate data with code that acts on that data. Every object is an <span class='firstuse'>instance</span>
of a class.  In other words, one class can provide a structure we use over and over again to make many objects. We make
objects from a class like we make a house from a blueprint. Each house we make has a color, a neighborhood, lights that
turn on and dishes to be cleaned.  Some houses that we make might be red, others brown, but we still need only that one
blueprint to know how to create the structure.  Once the house is built, we can perform actions like turning on the
lights or doing the dishes. When we define these actions in a class, we call them <span class='firstuse'>methods</span>.</p>
<p>Ruby's built-in classes allow us to do all kinds of great things, but they provide only general-purpose
functionality.  Most of the time we need to create our own classes so that our applications can do what we need them to
do. As an object-oriented language, Ruby allows Rails to provide powerful classes that encapsulate common patterns of
  web application development. We often create our own classes or <span class='firstuse'>sublcass</span> core Rails classes,
  extending them with custom behavior.<span class='ed'>THis section feels like it belongs in the "before you start" chapter. It
  doesn't fit with "who should read this book"</span><span class='author'>Sarah: After trying it everywhere else, I think it belongs
  back here. Also re-wrote it some, so hoping it works better now.</span></p>

    </div>
    <p>
      To understand Ruby and Rails we need to understand Ruby objects because they are the cornerstone of most programs we will write.  We will spend most of this chapter learning about objects and classes, along with common error messages that will become key when we start testing.  Before we get started with Ruby objects, lets begin our study of Ruby by becoming familiar with evaluating Ruby expressions and taking a little tour of Ruby's syntax.
    </p>
    <div class='sect1' id='ruby.lang.tools.syntax'>
      <h2 class='title'>Using <span class='commandname'>irb</span> to Explore the Ruby Language</h2>
        <p>
             Ruby comes equipped with <span class='commandname'>irb</span>, which stands for &ldquo;Interactive RuBy&rdquo;. It allows us to see how Ruby will interpret our code and is a valuable tool in our programmer toolbox.  We will be using <span class='commandname'>irb</span> throughout this chapter to see our code through Ruby's eyes. 
        </p>
        <p>  
            To access <span class='commandname'>irb</span>, we type <span class='commandname'>irb</span> into the command line.  This command gives us a prompt with an angle bracket &ldquo;>&rdquo; where we can type in Ruby code.  Don't worry if your command prompt looks a little different — it can be modified with configuration.
             Here's an example of <span class='commandname'>irb</span> in action:
             </p>
             <code language="session">
               $ irb
               > 1 + 1
             </code>
             <p>
               Now when we click enter, Ruby will evaluate 1 + 1 and <span class='commandname'>irb</span> will show us what it returns:
             </p>
             <code language="session">
               => 2
             </code>
             <p>
           Every time we ask <span class='commandname'>irb</span> to evaluate an expression, it will tell us the result of the evaluation.  
          </p>
          <p>
            Let's move on to exploring some common Ruby idioms using <span class='commandname'>irb</span>
          </p>
      <div class='sect2' id='ruby.poetry.syntax'>
            <h2 class='title'>Poetry Syntax</h2>
          <p>
          There are many reasons to love Ruby. One of them is its concise and sometimes poetic syntax. Forget about
          separating expressions with semi-colons and curly braces – we don't need to in Ruby.   We won't always wrap our arguments in parentheses unless we need them to indicate precedence.  Let's open up a terminal and type <span class='commandname'>irb</span>. Then try this out:
          </p>

          <code language="ruby">
            > def combo thing1, thing2
            ?>   thing1 + " and " + thing2
            ?>   end
             => nil
          </code>

          <code language="irb">
            > combo "peanut butter", "jelly"
            => "peanut butter and jelly" 
            > combo("pork chops", "applesauce")
            => "pork chops and applesauce"  
          </code>

          <p>
          We defined the <span class='method'>combo</span> method without parentheses around our parameters and the first time, we called
          <span class='method'>combo</span> we omitted parentheses around the arguments.  This is absolutely legal in Ruby and is
          called <em class='emph'>poetry syntax</em>. 
          </p>
          <div class='sidebar' id='side.dsl'>
            <h2 class='title'>Domain Specific Languages</h2>
            <p>
              The flexibility of Ruby's syntax makes it a popular language for the creation of <span class='firstuse'>domain-specific
              languages</span> (DSLs).  There are <span class='firstuse'>external</span> DSLs like SQL, which are
              domain-specific languages that are implemented using a different language and
              <span class='firstuse'>internal</span> DSLs which sit on top of another language, extending its syntax to the
              extent that it feels like a new language.</p>
              <p>Rails is a domain-specific language for web
              application development. RSpec is a DSL for writing executable specifications that test our code. Rake is
              a DSL for executing scripts. Rails, RSpec, and Rake are all internal DSLs written in Ruby. Since they are
              not only written in Ruby, but are executed as Ruby code, they may be extended using Ruby, which gives them
              all of the power and flexibility of Ruby itself.</p>
              <p>Ruby's poetry syntax and a few other language tricks allow Rails, RSpec and other Ruby DSLs to do a lot with
              very little code.  Understanding the difference between Ruby and DSLs written in Ruby gives us the power
              to quickly understand what code is doing. We will talk more about DSL's in our discussion of RSpec in <a class='ref' href='ch.rspec-intro'>ch.rspec-intro</a> and Rake in <a class='ref' href='ch.rake'>ch.rake</a>.
            </p>
          </div>
    </div> 
    
    <div class='sect2' id='ruby.objects'>
     <h2 class='title'>Everything Is an Object</h2>
     <p>
       Yep, it's true.  Everything in Ruby is an object, unlike many other languages.   The fact that strings and numbers are objects means that Ruby can define methods on them.  For example, lets change a string to uppercase:
     </p>

     <code language="irb">
     > "too big for my britches".upcase
      => "TOO BIG FOR MY BRITCHES"
     </code>

     <p>
        The quotation marks in &ldquo;too big for my britches&rdquo; create an instance of the
        <span class='rubyclass'>String</span> class where the <span class='method'>upcase</span> method is defined.  In some other languages strings and
        numbers are handled specially, but with Ruby they are objects created from built-in classes like <span class='rubyclass'>String</span>,
        <span class='rubyclass'>FixNum</span> and <span class='rubyclass'>Float</span>. Ruby also has built-in collections <span class='rubyclass'>Array</span> and
        <span class='rubyclass'>Hash</span> with a wide range of methods that you might have to build yourself in some old-school languages. 
       </p>
    </div>
    
    <div class='sect2' id='ruby.operators'>
      <h2 class='title'>Ruby Operators Are Methods</h2>
      <p>Ah, Ruby...always doing things with a bit of glitz.  Ruby operators are no different.  Most languages have
      operators built into the language as structures of their own.  Ruby defines methods in the <span class='rubyclass'>FixNum</span>
      and <span class='rubyclass'>Float</span> classes in order to get <span class='method'>+</span>, <span class='method'>-</span> and other operators...just
      like how <span class='method'>upcase</span> is defined on the <span class='rubyclass'>String</span> class.  This works because methods are
      just messaged in Ruby, and operators work the same way.  Let's check it out in <span class='commandname'>irb</span>.</p>
      <code language="session">
      > 1 + 1
      => 2
      </code>

             <p>The plus sign looks like just any old operator we might see in another programming language, but in Ruby it is a method.  Try this:</p>

             <code language="irb">
               > 1.+(1)
               => 2
             </code>

             <p>We can see that the plus symbol is actually a method called on a number object.  When we use the plus
             symbol without the dot Ruby is actually calling the <span class='method'>+</span> method behind the scenes.  Ruby gives us some syntactic sugar so that we can write code that looks like the math we learned in Kindergarten without dots.</p>

      			 <p>Other Ruby operators like <span class='ic'>-</span>, <span class='ic'>*</span>, and <span class='ic'>/</span> are also methods and work similarly:</p>

<code language="irb">
> 2.* 4
=> 8 
> 9./ 3
=> 3 
</code>
             <p>Ruby operators work for other objects too.  For instance array and string objects can be added together. In our own classes, we can define methods to make operators work in any way that we want.</p>

    </div> 
  </div>

  <div class='sect1' id='sec.ruby.class'>
    <h2 class='title'>Building Our Own Class</h2>
      <p>We've had a quick tour of Ruby concepts and syntax.  Now we are ready to build our own class and create objects
      from it.  Our goal in writing this class is to prepare us for test driven development.  The best way to prepare is
      to write our class step by step, just like how we will work once we are using tests. We'll actually test
      interactively to understand what happens in Ruby before we've written our code. We'll pay close attention to 
      each error message before learning the code that resolves the error. Knowing different errors and how to fix them
      is a crucial skill using any development methodology.
      Test driven code is first experienced as error driven code, so learning to read and understand Ruby errors will be key going forward.
     </p>    
     
     <p>
      The class we are about to build is very simple.  We are going to create a <span class='rubyclass'>Person</span> class that has a <span class='method'>full_name</span> method.  We will use this method later in Rails application that we build.  Let's get started!
     </p>
    
    <div class='sect2' id='giving_people_full_names'>
    <h2 class='title'>Giving People Full Names</h2>
    <p>The <span class='method'>full_name</span> method of our <span class='rubyclass'>Person</span> class will
    eventually concatenate different parts of our name together. We'll start in this chapter by building just one method
    interactively, then we'll test drive the other methods in the class in the next chapter.  With our <span class='rubyclass'>Person</span> class, we'll be able to make objects that respond the same way but have
       different data.
    </p> 
    
      <p>
      Before we get started writing code, we'll need a file. Ruby files end with a &ldquo;.rb&rdquo;
      extension.  By convention we'll name our file <span class='filename'>person.rb</span> after the class we plan to write, but
      it could be called <span class='filename'>super_full_name_maker.rb</span> and it would still work.
    </p>
    </div>
    
    <div class='sect2' id='person_object'>
    <h2 class='title'>Creating Our Person Object</h2>
    <p>
      Before we write any code, let's look at what happens if we try to use the Person class before we define it:
    </p>

    <code language="irb">
    $ irb
    > Person
    NameError: uninitialized constant Object::Person
      from (irb):1
    </code>

    <p>
      In Ruby, classes are constants.  When typing <span class='ic'>Person</span> above, Ruby knows that there isn't currently a
      <span class='rubyclass'>Person</span> class, so it throws a <span class='constant'>NameError</span> telling us that the
      <span class='rubyclass'>Person</span> constant doesn't exist. Ruby is case-sensitive and names that start with a capital
      letter are interpreted as constants. By convention, class names are camel case and all other constants are all caps.
    </p>
    
    <p>
      Let's try again after loading <span class='filename'>person.rb</span>.  Remember we just created the file, but it is
      still empty. We will see what happens just when we load a file in <span class='commandname'>irb</span>:
    </p>
    <code language="irb">
    > load 'person.rb'
     => true 
    </code>

    <p>
      Loading <span class='filename'>person.rb</span> reports true since it was able to successfully load the file and evaluate
      the nonexistant contents of the file as Ruby code. However <span class='rubyclass'>Person</span> is still not defined:</p>
    <code language="irb">
    > Person
    NameError: uninitialized constant Person
      from (irb):2
    </code>
      
      <p>Loading the file simply evaluates the text inside it as Ruby code and reports true if there are no syntax
      errors.</p>
    
    <p>
      Next let's add the class declaration to the file:
    </p>
    <a class='code' href='code/full_name/person.rb' part='class'>code/full_name/person.rb</a>   
    <p>
       Our code can now create <span class='rubyclass'>Person</span> objects.  We need to load the file again every time we make
       a change, and we can see that the class <span class='rubyclass'>Person</span> is defined:  
    </p>
<code language="irb">
> load 'person.rb'
=> true 
> Person
=> Person
</code>
<p>Let's
       create an object from our class with the <span class='method'>new</span> method:</p>
    <code language="irb">      
      p = Person.new
       => #&#060;Person:0x10044c6a8&#062;
    </code>
    
     <p>
       Our new Person object's is returned and stored in the variable <span class='ic'>p</span>. The whole expression evaluates to the
       value of the varable <span class='ic'>p</span>, so <span class='commandname'>irb</span> displays a text representation of the object,
       which includes its class, <span class='rubyclass'>Person</span>, and an encoded version of the object's id (0x10044c6a8).  If we make more objects of the <span class='rubyclass'>Person</span> class, each one will have a unique object id.  We haven't defined any methods in our <span class='rubyclass'>Person</span> class, yet look at our output when we ask our <span class='rubyclass'>Person</span> object for its methods:
     </p>
<code language="irb">
> p.methods
 => [:nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, :singleton_class,
 :clone, :dup, :initialize_dup, :initialize_clone, :taint, :tainted?, 
 :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect,
 :methods, :singleton_methods, :protected_methods, :private_methods, … 
 :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__] 
</code>
<joeasks id="symbols">
		<h2 class='title'>What are the names with the colons?</h2>
		<p>They are
    <span class='firstuse'>symbols</span>.   We use
    symbols to label objects, method names or other messages in our code. Symbols are created by
    putting a colon in front of some characters.</p>
    <p>Why are symbols better than strings for labels and
    messages? Each time we evaluate a string, an new object is created — not so with symbols.  Watch this:</p> 
		
		<code language="irb">
		> "thing".object_id
		=> 2160189120 
		> "thing".object_id
		=> 2152614520 
		> :thing.object_id
		=> 370728 
		> :thing.object_id
		=> 370728
		</code>
		
		<p>Our strings and our symbol are objects since everything in Ruby is an object.  When we ask each object for its
    id, the strings gives us a different id each time, while the symbol gives us the same id.  This means if we were to
    use strings as our arguments above, and then refer to those methods again by the strings, it would create twice as
    many objects as when we use symbols.</p>

    <p> Symbols can have numbers in them, but they need to start with a letter. Like everything else in Ruby, they are
    case-sensitive:</p>
		<code language="irb">
    > :a == :A
    => false    
    </code>	  
		<p>
		 We can think of symbols as being like labels for things.  They are kind of like a cross between strings and
     integers. They are immutable, which means they can't be changed. They are similar to integers, where 5 is always 5,
     yet they are made up of textual characters like strings which is nice when reading code.</p>
</div>
       <p>Our new Person object's return value shows the class of the object, <span class='rubyclass'>Person</span>, and a unique
       reference number (0x10044c6a8).  If we make more objects of the <span class='rubyclass'>Person</span> class, each one
       will be unique. Right now each instance of the class will act exactly the same, we haven't defined
       any methods in our <span class='rubyclass'>Person</span> class yet.
     </p>
     </div>
     
     <sect2>
     <h2 class='title'>Defining the <span class='method'>full_name</span> Method</h2>
     <p>
       We'll need to add the <span class='method'>full_name</span> method to the <span class='rubyclass'>Person</span> class in
       order for its objects to have useful functionality outside of its inherited methods.  Before we change our code,
       let's check out what happens when we call the non-existent <span class='method'>full_name</span> method on our <span class='rubyclass'>Person</span> object:
     </p>

     <code language="irb">
     > p.full_name
     NoMethodError: undefined method `full_name` for #&#060;Person:0x10044c6a8&#062;
       from (irb):19
     </code>

     <p>
       This time our error message is a <span class='constant'>NoMethodError</span>.  It tells us that currently the
       <span class='method'>full_name</span> method is not defined.  Now we can edit
       <span class='filename'>person.rb</span> so that it has a <span class='method'>full_name</span> method. For starters, we
       won't make the method do anything, we'll just define an empty method to understand how it behaves:
     </p>
     <a class='code' href='code/full_name/person.rb' part='define_method'>code/full_name/person.rb</a>   
     <p>
       When we reload <span class='filename'>person.rb</span> and call the <span class='method'>full_name</span> method, nil is returned.
     </p>
     
     <code language="irb">
     > p.full_name
      => nil
     </code>
     
     <p>Earlier we learned that everything in Ruby returns something.  Our <span class='method'>full_name</span> method
     returns nil because all empty methods return nil. <span class='ic'>Nil</span> isn't some special case literal, it is an
     <span class='rubyclass'>Object</span>
     just like everything in Ruby. We can see in <span class='commandname'>irb</span> that <span class='ic'>nil</span> is an instance of <span class='rubyclass'>NilClass</span>
     and we can even call methods on it:</p>
<code language="irb">
>> nil
=> nil
>> nil.class
=> NilClass
>> nil.nil?
=> true
</code>     
     <p>If we want it to return a value other than nil, say the string &ldquo;Jane Smith&rdquo;, we can put our string inside of our method and Ruby will return the string when we call <span class='method'>full_name</span>.</p>

     <a class='code' href='code/full_name/person.rb'>code/full_name/person.rb</a>
     <p>Ruby methods return the last expression evaluated automatically so we don't need to use the
     <span class='keyword'>return</span> keyword (though we can if we want to).  Now our <span class='method'>full_name</span> method
     should return the string &ldquo;Jane Smith&rdquo; instead of <span class='ic'>nil</span>.  Let's try it out: </p>

     <code language="irb">
      > load 'person.rb'
      => true
      > p = Person.new
      => #&#060;Person:0x10044c6a8&#062;
      > p.full_name
       => "Jane Smith"
     </code>
     
     <p>We reloaded the file again so that <span class='commandname'>irb</span> knows about our changes.  We can see that our
     <span class='method'>full_name</span> method now returns our string as we had hoped.</p>
     </div>
<sect2>
<h2 class='title'>Object Construction</h2>
<p>Our code would be working great if all of our users were named &ldquo;Jane Smith&rdquo;. Of course our users will have a variety of names, so we need a more intelligent solution.  We know that each person we create must have a name.  Given this knowledge, let's give each person a name when their <span class='rubyclass'>Person</span> object is first created.</p>
<p>Ruby has a special <span class='method'>initialize</span> method that allows us to execute code whenever a new object is instantiated.  Often the <span class='method'>initialize</span> method is used to set up attributes for an object.  In our case we want to put data into attributes for a person's name. Let's add an <span class='method'>initialize</span> method to our <span class='method'>Person</span> class:</p>
     <a class='code' href='code/full_name/person_initialize.rb' part='one'>code/full_name/person_initialize.rb</a>
<p>Then let's see it in action:</p>
<code language="irb">
> load 'person.rb'
=> true
> p = Person.new
> p = Person.new
Hello! I am being created at 2011-04-02 14:54:20 -0700.
=> #&#060;Person:0x10044c6a8&#062; 
</code>
<p>We can see that when we call <span class='method'>new</span> on any class, Ruby will call the
<span class='method'>initialize</span> method of the class, if there is one. The newly created object is always returned
from <span class='method'>new</span> and the return value from <span class='method'>initialize</span> is ignored.</p>
<p>Our plan is to make this class accept a first and last name, but for now let's get a feel for how this works by
starting with just one name as an argument in the initialize method. After all, some people have only one name:</p>
     <a class='code' href='code/full_name/person_initialize.rb' part='two'>code/full_name/person_initialize.rb</a>
<p>and Ruby will then require an argument for new:</p>
<code language="irb">
> load 'person.rb'
=> true
>> p = Person.new
ArgumentError: wrong number of arguments (0 for 1)
	from (irb):5:in `initialize'
	from (irb):5:in `new'
	from (irb):5
</code>
<p>which we can provide just like any other method argument:</p>
<code language="irb">
>> p1 = Person.new("Sacajawea")
Sacajawea is being created.
=> #&#060;Person:0x10044c6a8&#062;
>> p2 = Person.new("Teller")
Teller is being created.
=> #&#060;Person:0x10044c6a8&#062;
</code>
<p>We've made good progress, but our <span class='method'>full_name</span> will still report “Jane Smith” for every object. What we really want to do is to save that data inside each object to reference later.  Let's do that next.</p>
</div>
<sect2>
<h2 class='title'>Storing Data with Objects</h2>
<p>A core concept of object-oriented programming is data encapsulation. We hide the details of the implementation of our
objects inside classes. We make some data available externally and some data remains private. We store data inside of our
objects in <span class='firstuse'>instance variables</span>.  We tell Ruby that a variable is an instance variable by putting a
<em class='emph'>@</em> before the variable.  A variable without the <em class='emph'>@</em> will only be available within the scope of
the method that uses it. </p>
<p>For example, if we try to just use the <span class='ic'>name</span> variable that we have in <span class='method'>initialize</span> in
another method:</p>
     <a class='code' href='code/full_name/person_instance_variable1.rb' part='one'>code/full_name/person_instance_variable1.rb</a>
<p>and then call that method:</p>
<code language="irb">
> load 'person.rb'
=> true
>> p1 = Person.new("Sacajawea")
Sacajawea is being created.
=> #&#060;Person:0x10044c6a8&#062;
>> p1.full_name
NameError: undefined local variable or method `name' for #&#060;Person:0x10044c6a8&#062;
	from ./person_instance_variable.rb:8:in `full_name'
	from (irb):3
</code>
<p>Ruby expects words that start with a lower case letter to be either a local variable or a
method. We haven't set a local variable called <span class='ic'>name</span> inside the <span class='method'>full_name</span> method, nor
have we defined a different method called <span class='method'>name</span>, so Ruby raises a <span class='ic'>NameError</span>.</p>
<p>To make a variable available across methods, we can set an instance variable in one method and use its value in
another, like this:</p>
<a class='code' href='code/full_name/person_instance_variable2.rb'>code/full_name/person_instance_variable2.rb</a>
<p>Now we can call <span class='method'>full_name</span> to get the appropriate name:</p>
<code language="irb">
> load 'person.rb'
=> true
>> p1 = Person.new("Sacajawea")
Sacajawea is being created.
=> #<Person:0x10123aa08 @name="Sacajawea">
>> p1.full_name
=> "Sacajawea"
>> p2 = Person.new("Teller")
Teller is being created.
=> #<Person:0x10120f150 @name="Teller">
>> p2.full_name
=> "Teller"
</code>
<p>Instance variables are always private, which means that they are not available by default outside of our
class:</p>
<code language="irb">
> p1.@name
SyntaxError: compile error
(irb):11: syntax error, unexpected tIVAR
	from (irb):11
> p1.name
NoMethodError: undefined method `name` for #&#060;Person:0x10044c6a8&#062;
  from (irb):19
</code>
<p>In Ruby, we define methods to expose the data that we want to share with the rest of the world.</p>
</div>
</div>

<sect1>
	<h2 class='title'>Inheritance</h2>
	<p>We now have a functioning Person class and we can make as many person objects as we want, each with their own full name.  </p>
	<p>What if we want a more specialized kind of person...say a student?  Students are definitely people, but they have
  some characteristics that are unique such as major, GPA, and year in school. If we wanted to give the qualities of
  personhood to students, we would use inheritance. We could make Student a <span class='firstuse'>subclass</span> of Person.</p>
  <p>In fact, we have already used inheritance. Every class, by default, is a subclass of <span class='rubyclass'>Object</span>.
  Check out some of the built-in behaviors that <span class='rubyclass'>Person</span> inherits from
  <span class='rubyclass'>Object</span>:</p>
<code language="irb">
     > p1.class
      => Person
     > p1.class.superclass
      => Object 
</code>  
   <p>
       The Ruby Object object provides many useful methods for free in any class we create, because every class in Ruby is a descendent of the <span class='rubyclass'>Object</span> class where all these methods are defined.  We can discover the methods of an object like this:
    </p>
<code language="irb">
> p1.methods
 => [:full_name, :nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, 
 :singleton_class, :clone, :dup, :initialize_dup, :initialize_clone, 
 …] 
</code>

<p>We can get the same list by calling <span class='ic'>Person.instance_methods</span>. If we want to see just the instance methods of
the <span class='rubyclass'>Person</span> class, we can subtract the <span class='rubyclass'>Object</span> instance methods:</p>
<code language="irb">
> Person.instance_methods - Object.instance_methods
 => [:full_name] 
</code>
<p>Both <span class='ic'>Person.instance_methods</span> and <span class='ic'>Object.instance_methods</span> return arrays of their methods.  The Array class defines the minus operator to remove elements from a list. Ruby and <span class='commandname'>irb</span> makes this kind of experimentation easy.</p>
<p>Now that we understand how our <span class='rubyclass'>Person</span> class inherits behavior from the
<span class='rubyclass'>Object</span> class. Let's make a new <span class='rubyclass'>Student</span> class that inherit from our
<span class='rubyclass'>Person</span> class and defines new behavior. We use an angle bracket to indicate inheritance.</p>
	<a class='code' href='code/full_name/person_inheritance.rb'>code/full_name/person_inheritance.rb</a>
	<p>Let's try out our new class in <span class='commandname'>irb</span>:</p>
	<code>
	> load 'person_inheritance.rb'
	=> true
	> s = Student.new("Birtha")
	=> #&#060;Person:0x10044c6a8&#062;
	> s.full_name
	=> "Birtha"
	> s.occupation
	=> "Student"

	</code>
	
<p> We can see that even though the <span class='method'>full_name</span> method is not defined in the <span class='rubyclass'>Student</span> class, our instance of <span class='rubyclass'>Student</span> has inherited the <span class='method'>full_name</span> from it's <span class='rubyclass'>Person</span> parent.</p>
</div>

<sect1> 
			<h2 class='title'>Rails Is Ruby</h2>
<p>We've learned a lot about Ruby in this chapter.  We've seen that Ruby is made of objects and we can make Ruby objects from built-in classes or from our own custom classes.  We've started understanding the classes that provide a blueprint for our objects and the methods that bring our objects to life.  This understanding will help us understand that the built in Rails classes provide specific blueprints that create patterns for web applications.</p>
      
			<p>We've introduced a few key concepts in Ruby that will make Rails syntax much more clear.  For example when we begin learning about ActiveRecord we will see model code that looks like this:
      </p>
		
      <code language="ruby">
         class Person < ActiveRecord::Base
         end
      </code>
	
      <p>We now know that this Rails model is really just a Ruby class.  The <span class='rubyclass'>Person</span> class inherits from the <span class='rubyclass'>ActiveRecord::Base</span> class. </p>
      
      <p>When we see code like:</p>
	
      <code language="ruby">
      belongs_to :user
      </code>
    <p>We might be able to guess that <span class='method'>belongs_to</span> is a Ruby method making use of Ruby's allowance of
    omitted parentheses. The symbol <span class='ic'>:user</span> is an argument to the method. </p>



<p>Since Ruby is an interpreted language, we have had an opportunity to play with code in the Interactive Ruby
environment, <span class='commandname'>irb</span>. Our <span class='commandname'>irb</span> exploration has given us a taste of what
testing our code will be like. We've learned to read and understand the error
    messages <span class='ic'>NameError: uninitialized Constant</span> when a class doe not exists and <span class='ic'>NoMethodError</span> if we
    call a method that doesn't exist. We will see these errors frequently as we use RSpec to test drive Rails, and being familiar with them will help to us in our development. 


We have learned the basics of Ruby that we will need to understand RSpec in the next chapter and Rails in later chapters.  With our new understanding of the fundamentals, it's time to move on and learn how to write Ruby code <em class='emph'>test first</em>. </p>
    
</div>
</div>
